program hyrackscc;

import java.util.UUID;
import java.util.Set;

import jol.types.basic.Tuple;
import jol.types.basic.TupleSet;

import edu.uci.ics.hyracks.api.dataflow.ActivityNodeId;
import edu.uci.ics.hyracks.api.dataflow.OperatorDescriptorId;
import edu.uci.ics.hyracks.api.dataflow.IOperatorDescriptor;
import edu.uci.ics.hyracks.api.dataflow.ConnectorDescriptorId;
import edu.uci.ics.hyracks.api.dataflow.IConnectorDescriptor;
import edu.uci.ics.hyracks.api.job.JobStatus;
import edu.uci.ics.hyracks.api.job.JobPlan;

define(activitystage_temp, keys(), {UUID, OperatorDescriptorId, ActivityNodeId, Integer});

activitystage_INITIAL activitystage_temp(JobId, OperatorId, ActivityId, 0) :-
    activitynode(JobId, OperatorId, ActivityId, _);

activitystage_BLOCKED activitystage_temp(JobId, OperatorId2, ActivityId2, StageNumber) :-
    activitystage_temp(JobId, OperatorId1, ActivityId1, StageNumber1),
    activitystage_temp(JobId, OperatorId2, ActivityId2, StageNumber2),
    activityblocked(JobId, OperatorId1, ActivityId1, OperatorId2, ActivityId2),
    StageNumber2 <= StageNumber1
    {
        StageNumber := StageNumber1 + 1;
    };

activitystage_PIPELINED_1 activitystage_temp(JobId, OperatorId2, ActivityId2, StageNumber) :-
    activitystage_temp(JobId, OperatorId1, ActivityId1, StageNumber1),
    activitystage_temp(JobId, OperatorId2, ActivityId2, StageNumber2),
    activityconnection(JobId, OperatorId1, Operator1Port, edu.uci.ics.hyracks.api.dataflow.Direction.OUTPUT, ActivityId1, _),
    activityconnection(JobId, OperatorId2, Operator2Port, edu.uci.ics.hyracks.api.dataflow.Direction.INPUT, ActivityId2, _),
    connectordescriptor(JobId, _, OperatorId1, Operator1Port, OperatorId2, Operator2Port, _),
    StageNumber1 != StageNumber2
    {
        StageNumber := java.lang.Math.max(StageNumber1, StageNumber2);
    };

activitystage_PIPELINED_2 activitystage_temp(JobId, OperatorId1, ActivityId1, StageNumber) :-
    activitystage_temp(JobId, OperatorId1, ActivityId1, StageNumber1),
    activitystage_temp(JobId, OperatorId2, ActivityId2, StageNumber2),
    activityconnection(JobId, OperatorId1, Operator1Port, edu.uci.ics.hyracks.api.dataflow.Direction.OUTPUT, ActivityId1, _),
    activityconnection(JobId, OperatorId2, Operator2Port, edu.uci.ics.hyracks.api.dataflow.Direction.INPUT, ActivityId2, _),
    connectordescriptor(JobId, _, OperatorId1, Operator1Port, OperatorId2, Operator2Port, _),
    StageNumber1 != StageNumber2
    {
        StageNumber := java.lang.Math.max(StageNumber1, StageNumber2);
    };

watch(activitystage_temp, a);

watch(activityconnection, a);
watch(activityblocked, a);
watch(operatordescriptor, a);
watch(connectordescriptor, a);

watch(activitystage, a);
watch(activitystage, i);
watch(activitystage, d);

define(activitystage, keys(0, 1, 2), {UUID, OperatorDescriptorId, ActivityNodeId, Integer});

activitystage(JobId, OperatorId, ActivityId, max<StageNumber>) :-
    activitystage_temp(JobId, OperatorId, ActivityId, StageNumber);

define(jobstage, keys(0, 1), {UUID, Integer, UUID});

jobstage(JobId, StageNumber, StageId) :-
    activitystage(JobId, _, _, StageNumber)
    {
        StageId := java.util.UUID.randomUUID();
    };

watch(jobstage, a);

define(stagestart, keys(), {UUID, Integer, Integer});
define(stagefinish, keys(0, 1), {UUID, Integer, Set});

watch(jobstart, i);

stagestart_INITIAL stagestart(JobId, 0, 0) :-
    jobstart(JobId, _),
    job(JobId, edu.uci.ics.hyracks.api.job.JobStatus.INITIALIZED, _, _, _),
    notin stagestart(JobId, _, _);

update_job_status_RUNNING job(JobId, edu.uci.ics.hyracks.api.job.JobStatus.RUNNING, JobSpec, JobPlan, null) :-
    job(JobId, edu.uci.ics.hyracks.api.job.JobStatus.INITIALIZED, JobSpec, JobPlan, _),
    jobstart(JobId, _);

stagestart_NEXT stagestart(JobId, NextStageNumber, 0) :-
    stagestart(JobId, StageNumber, _),
    stagefinish#insert(StageId, StageNumber, _)
    {
        NextStageNumber := StageNumber + 1;
    };

stagestart_AGAIN stagestart(JobId, StageNumber, NextAttempt) :-
    stagestart(JobId, StageNumber, Attempt),
    abortcomplete(JobId, StageId, Attempt),
    jobstage(JobId, StageNumber, StageId)
    {
        NextAttempt := Attempt + 1;
    };

watch(stagestart, a);
watch(stagestart, d);

define(activitystart, keys(), {UUID, OperatorDescriptorId, ActivityNodeId, Integer, Integer, UUID, String});

activitystart(JobId, OperatorId, ActivityId, StageNumber, Attempt, StageId, NodeId) :-
    stagestart(JobId, StageNumber, Attempt),
    operatordescriptor(JobId, OperatorId, _),
    activitystage(JobId, OperatorId, ActivityId, StageNumber),
    jobstage(JobId, StageNumber, StageId),
    operatorlocation(JobId, OperatorId, NodeId);

watch(activitystart, a);

define(stageletstart, keys(0, 1, 3, 4), {UUID, UUID, JobPlan, String, Integer, Set});

stageletstart(JobId, StageId, JobPlan, NodeId, Attempt, set<ActivityId>) :-
    activitystart#insert(JobId, _, ActivityId, StageNumber, Attempt, StageId, NodeId),
    job(JobId, edu.uci.ics.hyracks.api.job.JobStatus.RUNNING, _, JobPlan, _);

watch(stageletstart, a);
watch(stageletstart, i);

define(startmessage_agg, keys(0, 1, 2), {UUID, UUID, Integer, JobPlan, Set});

startmessage_agg(JobId, StageId, Attempt, JobPlan, set<Tuple>) :-
    stageletstart(JobId, StageId, JobPlan, NodeId, Attempt, ActivityIdSet)
    {
        Tuple := [NodeId, ActivityIdSet];
    };

startmessage(JobId, StageId, Attempt, JobPlan, TSet) :-
    startmessage_agg(JobId, StageId, Attempt, JobPlan, TSet);

watch(startmessage, a);
watch(startmessage, i);

define(stageletabort, keys(0, 1, 3, 4), {UUID, UUID, JobPlan, String, Integer, Set});

stageletabort(JobId, StageId, JobPlan, NodeId, Attempt, ActivityIdSet) :-
    stageletstart(JobId, StageId, JobPlan, NodeId, Attempt, ActivityIdSet),
    failednodes(NodeId);

stageletabort(JobId, StageId, JobPlan, NodeId, Attempt, ActivityIdSet) :-
    stageletstart(JobId, StageId, JobPlan, NodeId, Attempt, ActivityIdSet),
    stageletabort(JobId, StageId, _, _, Attempt, _);

define(abortmessage_agg, keys(0, 1, 2), {UUID, UUID, Integer, JobPlan, Set});

abortmessage_agg(JobId, StageId, Attempt, JobPlan, set<Tuple>) :-
    stageletabort(JobId, StageId, JobPlan, NodeId, Attempt, ActivityIdSet),
    notin failednodes(NodeId)
    {
        Tuple := [NodeId, ActivityIdSet];
    };

abortmessage(JobId, StageId, Attempt, JobPlan, TSet) :-
    abortmessage_agg(JobId, StageId, Attempt, JobPlan, TSet);

watch(abortmessage, a);
watch(abortmessage, i);

define(abortnotify_agg, keys(0, 1, 2), {UUID, UUID, Integer, Set});

abortnotify_agg(JobId, StageId, Attempt, set<NodeId>) :-
    abortnotify(JobId, StageId, NodeId, Attempt);

define(abortcomplete, keys(), {UUID, UUID, Integer});

abortcomplete(JobId, StageId, Attempt) :-
    abortnotify_agg(JobId, StageId, Attempt, NodeIdSet),
    abortmessage_agg(JobId, StageId, Attempt, _, TSet),
    TSet.size() == NodeIdSet.size();

define(stageletcomplete_agg, keys(0, 1, 2), {UUID, UUID, Integer, Set});

stageletcomplete_agg(JobId, StageId, Attempt, set<Statistics>) :-
    stageletcomplete(JobId, StageId, NodeId, Attempt, Statistics);

stagefinish(JobId, StageNumber, SSet) :-
    startmessage_agg(JobId, StageId, Attempt, _, TSet),
    stageletcomplete_agg(JobId, StageId, Attempt, SSet),
    jobstage(JobId, StageNumber, StageId),
    TSet.size() == SSet.size();

update_job_status_TERMINATED job(JobId, edu.uci.ics.hyracks.api.job.JobStatus.TERMINATED, JobSpec, JobPlan, null) :-
    job(JobId, edu.uci.ics.hyracks.api.job.JobStatus.RUNNING, JobSpec, JobPlan, _),
    stagestart#insert(JobId, StageNumber),
    stagefinish(JobId, _, SSet),
    notin jobstage(JobId, StageNumber);